04 - Object Oriented Programming
===============
>PHP5 is an enterprise grade object oriented programming language. This week, we will be looking at how to build classes
that we will later use, at runtime, to instantiate objects. Instantiated objects can take on different forms, depending
on the context in which they were created.
>In writing some OO code we will briefly delve into some design patterns.

***

OOP Fundamentals
----------------
Lets take a look at some syntax that we can use to create classes, instantiate objects from those newly created classes and
create a parent child relationship where applicable.

#### Defining a class
```php
<?php

class Person
{
    /**
     * Person's numeric identifier (usually generated by the database)
     *
     * @var int
     */
    protected $id;

    /**
     * Person's full name
     *
     * @var string
     */
    protected $name;

    /**
     * Person's billing address.
     *
     * @note  : I should have named this property billingAddress for clarity
     *        Regardless of the variable name, be sure to document all your properties.
     * @var string
     */
    protected $address;

    /**
     * Create a new person
     * @param int $id personId from the database
     * @param string $name Person's full name
     * @param string $address Billing address
     */
    public function __construct($id, $name, $address)
    {
        $this->id = $id;
        $this->name = $name;
        $this->address = $address;
    }

    /**
     * @return string
     */
    public function getAddress()
    {
        return $this->address;
    }

    /**
     * @return int
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }
}
```

#### Instantiating an object

Now that we have created a person class, lets use it to create a concrete person object.
The object that we are about to create is unique because of the data that we pass to it via constructor arguments.
```php
<?php

$InstructorPerson = new Person(5, 'Samir Patel', '5000 Memory Lane');
print_r($InstructorPerson);
```

The output we get will look something like this. Notice that it tells us that the kind of object we are looking at is ```Person```
The person we are looking at here is really an instructor.
```
Person Object
(
    [id:protected] => 5
    [name:protected] => Samir Patel
    [address:protected] => 5000 Memory Lane
)
```
Instructor's teach several classes, but ```Person```s do not. ```Student```s take a class or they can take multiple classes.
We could add two properties to the ```Person``` class and call them ```$coursesTaught``` and ```$coursesTaken```.
This solution is far from ideal, because now every time we create an instructor, we will have ```$coursesTaken``` and when we
create a student, we will have an extra property for ```$coursesTaught```.
We will be using *Inheritance*, a staple of object oriented design, to solve this classic problem.

#### Inheritance
Inheritance allows you to extend a parent class and add functionality to it, and/or override any existing functionality it contains.
We will create two classes ```Instructor``` and ```Student``` and add the aforementioned properties to each one.
```php
<?php

class Student extends Person
{
    /**
     * An array of all courses that this student has taken
     *
     * @var array
     */
    protected $coursesTaken = array();

    /**
     * Add a course to the list of courses this student is taking
     *
     * @param string $courseName Name of the course this student is taking
     * @return Student
     */
    public function addTakenCourse($courseName)
    {
        $this->coursesTaken[] = $courseName;
        return $this;
    }
}

class Instructor extends Person
{
    /**
     * List of course names this instructor is teaching
     *
     * @var array
     */
    protected $coursesTaught = array();

    /**
     * Add a course to the array of courses this instructor is teaching
     *
     * @param string $courseName Name of the course this instructor is teaching
     * @return Instructor
     */
    public function addTaughtCourse($courseName)
    {
        $this->coursesTaught[] = $courseName;
        return $this;
    }
}
```
Create a student, and pile on a heavy course load.
```php
<?php

$IndustriousStudent = new Student(123, 'Albert Einstein', 'Munich, Germany');

// You can chain methods like this because you returned $this in your addTakenCourse() method
// $this is pseudo variable that is an internal reference to the current object you are accessing or mutating
$IndustriousStudent->addTakenCourse('Advanced Python')->addTakenCourse('Advanced PHP');
$IndustriousStudent->addTakenCourse('Particle Physics');
print_r($IndustriousStudent);
```

Notice how the object is now of type ```Student``` not ```Person```.
Also notice how the ```id```, ```name``` and ```address``` properties are inherited from the parent class ```Person```

```
Student Object
(
    [coursesTaken:protected] => Array
        (
            [0] => Advanced Python
            [1] => Advanced PHP
            [2] => Particle Physics
        )

    [id:protected] => 123
    [name:protected] => Albert Einstein
    [address:protected] => Munich, Germany
)
```

Lets create an ```Instructor``` and add some taught courses
```php
<?php

$ACAInstructor = new Instructor(456, 'Samir Patel', 'Austin TX');
$ACAInstructor->addTaughtCourse('Intermediate PHP');
$ACAInstructor->addTaughtCourse('Advanced PHP');
$ACAInstructor->addTaughtCourse('Golfing like a boss');
print_r($ACAInstructor);
```

Notice how the object is of type ```Instructor``` and has the ```$coursesTaught``` property instead of ```$coursesTaken```
```
Instructor Object
(
    [coursesTaught:protected] => Array
        (
            [0] => Intermediate PHP
            [1] => Advanced PHP
            [2] => Golfing like a boss
        )

    [id:protected] => 456
    [name:protected] => Samir Patel
    [address:protected] => Austin TX
)
```

Classes explained
-----------------

#### Constructors, arguments and overloading
A constructor looks like this ```___construct()```. A constructor is a way for you to define the arguments the class
will take when you instantiate it. When we say ```$Obj = new MyCoolClass();``` we are *instantiating* the class into an object.

Lets create a simple class called ```Weather```.
Notice that this class has two constructor arguments, ```$temperature``` and ```$location```.
The ```$location``` argument has a default value.
In other words, you don't need to specify the location when you instantiate the class, as its optional.

```php
<?php

class Weather
{
    /**
     * @param float $temperature Temperature in fahrenheit
     * @param string $location City name
     */
    public function __construct($temperature, $location = 'Austin')
    {
        if ($temperature > 80) {
            echo "It is super hot in $location";
        } else {
            echo "Its really cold in $location";
        }
    }
}
```
Let's instantiate this class in a few different ways, and examine the output.
```php
<?php

$EastWeather = new Weather(88.50, 'Bombay'); // Outputs: It is super hot in Bombay
$NorthWeather = new Weather(60.34, 'Alaska'); // Outputs: Its really cold in Alaska
```
Notice that when we instantiate a class into an object,
the first thing that runs is all the code you have defined in the constructor.

#### Public, private and protected methods and properties
A method is simply a function inside of a class. A property is a variable inside a class.
PHP has three levels of visibility that apply to methods and properties.

* ```public``` - Anything prefixed with the public keyword can be accessed and mutated from anywhere.
* ```protected``` - This prefix only allows the current class and any child class visibility and mutability.
* ```private``` - Private methods and properties can only be accessed from within the class that they were defined.

The reason why we have the ability to control visibility is so when other developers read our code, it becomes clear to them
what we want them to be able to modify and what is off limits. Lets take a look at an example of how visibility is useful.
Note that if we print out an object, using ```print_r()``` or ```var_dump()``` you will still see the value of the variable.

```php
<?php

class Employee
{
    /**
     * @var string
     */
    protected $name;

    /**
     * Any medical condition this employee has
     *
     * @var string
     */
    private $medicalCondition;

    /**
     * @param string $medicalCondition
     */
    public function setMedicalCondition($medicalCondition)
    {
        $this->medicalCondition = $medicalCondition;
    }

    /**
     * @return string
     */
    public function getMedicalCondition()
    {
        return $this->medicalCondition;
    }

    /**
     * @param string $name
     */
    public function setName($name)
    {
        $this->name = $name;
    }

    /**
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }
}
```
Now that we have created one private property in this class, lets instantiate it and print_r the object.

```php
$Adult = new Employee();
$Adult->setMedicalCondition('The Shakes');
$Adult->setName('John Doe');
print_r($Adult);
```

Here is the output from ```print_r($Adult);```
```php
Employee Object
(
    [name:protected] => John Doe
    [medicalCondition:Employee:private] => The Shakes
)
```

As you can see, even though the property is private, we can still see the data it contains when we print the object.

Lets create a child class, and call it ```ChildEmployee```, and try to access the parent's private property.

```php
<?php

class ChildEmployee extends Employee
{
    /**
     * I can access the parent's medical condition property,
     * because I am calling it via a getter, whose visibility is public.
     */
    public function readMedicalCondition()
    {
        echo 'Medical Condition: ' . $this->getMedicalCondition();
    }

    /**
     * I cannot access a private property from a child class
     */
    public function accessMedicalConditionProperty()
    {
        echo $this->medicalCondition;
    }
}
```

Our new class contains two new methods called ```readMedicalCondition()``` and ```accessMedicalConditionProperty()```.
Lets instantiate the class into an object and call those methods.
```php
<?php

$Child = new ChildEmployee();
$Child->setName('Bonobo');
$Child->setMedicalCondition('Shivers');

// This works
echo 'Read using public getter: '. $Child->getMedicalCondition();

// This does not work
$Child->accessMedicalConditionProperty(); // Notice: Undefined property: ChildEmployee::$medicalCondition
```

The reason why we can read the medical condition with this method is because it is using the parent's ```getMedicalCondition()``` method.

Since the ```getMedicalCondition()``` method in the ```Employee``` class is public, is defined in the parent class and accesses
a private property defined in the same class, we can read the value for medical condition.

When we try to call the ```accessMedicalConditionProperty()``` method it fails because the method is trying to directly access
the private property ```$medicalCondition``` that is defined in the parent ```Employee``` class.

### Class constants
Class constants are defined using the ```const``` keyword, are not prefixed with a ```$``` symbol and are uppercase by convention.
Constants can only contain primitive values like integers, floats and strings.
```php
<?php

class Foo
{
    const BAR = 'fubar';

    const NUM_COUNTRIES_ON_EARTH = 193;

    public function displayConstant()
    {
        echo self::BAR;
    }
}
```

Here is how you would access the constants

```php
$F = new Foo();

// How to access the constant internally
$F->displayConstant();

// How to access the constant from the outside the class
echo 'There are ' . Foo::NUM_COUNTRIES_ON_EARTH .' countries on earth';
```


*
*
* Static methods
* Static properties
* How to access object properties
* The $this keyword
* The self keyword

### Abstract Classes & Interfaces
* What is an abstract class?
* What is an interface?
* Whats the difference?
* What can we use this for?

### Exceptions revisited
* Base Exception class
* Overriding Exception by extending
* Why would we want to override the base Exception class?
* How to throw your own Exceptions and why it matters
