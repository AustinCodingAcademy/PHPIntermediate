04 - Object Oriented Programming
===============
>PHP5 is an enterprise grade object oriented programming language. This week, we will be looking at how to build classes
that we will later use, at runtime, to instantiate objects. Instantiated objects can take on different forms, depending
on the context in which they were created.
>In writing some OO code we will briefly delve into some design patterns.

***

OOP Fundamentals
----------------
Lets take a look at some syntax that we can use to create classes, instantiate objects from those newly created classes and
create a parent child relationship where applicable.

#### Defining a class
```php
<?php

class Person
{
    /**
     * Person's numeric identifier (usually generated by the database)
     *
     * @var int
     */
    protected $id;

    /**
     * Person's full name
     *
     * @var string
     */
    protected $name;

    /**
     * Person's billing address.
     *
     * @note  : I should have named this property billingAddress for clarity
     *        Regardless of the variable name, be sure to document all your properties.
     * @var string
     */
    protected $address;

    /**
     * Create a new person
     * @param int $id personId from the database
     * @param string $name Person's full name
     * @param string $address Billing address
     */
    public function __construct($id, $name, $address)
    {
        $this->id = $id;
        $this->name = $name;
        $this->address = $address;
    }

    /**
     * @return string
     */
    public function getAddress()
    {
        return $this->address;
    }

    /**
     * @return int
     */
    public function getId()
    {
        return $this->id;
    }

    /**
     * @return string
     */
    public function getName()
    {
        return $this->name;
    }
}
```

#### Instantiating an object

Now that we have created a person class, lets use it to create a concrete person object.
The object that we are about to create is unique because of the data that we pass to it via constructor arguments.
```php
<?php

$InstructorPerson = new Person(5, 'Samir Patel', '5000 Memory Lane');
print_r($InstructorPerson);
```

The output we get will look something like this. Notice that it tells us that the kind of object we are looking at is ```Person```
The person we are looking at here is really an instructor.
```
Person Object
(
    [id:protected] => 5
    [name:protected] => Samir Patel
    [address:protected] => 5000 Memory Lane
)
```
Instructor's teach several classes, but ```Person```s do not. ```Student```s take a class or they can take multiple classes.
We could add two properties to the ```Person``` class and call them ```$coursesTaught``` and ```$coursesTaken```.
This solution is far from ideal, because now every time we create an instructor, we will have ```$coursesTaken``` and when we
create a student, we will have an extra property for ```$coursesTaught```.
We will be using *Inheritance*, a staple of object oriented design, to solve this classic problem.

#### Inheritance
Inheritance allows you to extend a parent class and add functionality to it, and/or override any existing functionality it contains.
We will create two classes ```Instructor``` and ```Student``` and add the aforementioned properties to each one.
```php
<?php

class Student extends Person
{
    /**
     * An array of all courses that this student has taken
     *
     * @var array
     */
    protected $coursesTaken = array();

    /**
     * Add a course to the list of courses this student is taking
     *
     * @param string $courseName Name of the course this student is taking
     * @return Student
     */
    public function addTakenCourse($courseName)
    {
        $this->coursesTaken[] = $courseName;
        return $this;
    }
}

class Instructor extends Person
{
    /**
     * List of course names this instructor is teaching
     *
     * @var array
     */
    protected $coursesTaught = array();

    /**
     * Add a course to the array of courses this instructor is teaching
     *
     * @param string $courseName Name of the course this instructor is teaching
     * @return Instructor
     */
    public function addTaughtCourse($courseName)
    {
        $this->coursesTaught[] = $courseName;
        return $this;
    }
}
```
Create a student, and pile on a heavy course load.
```php
<?php

$IndustriousStudent = new Student(123, 'Albert Einstein', 'Munich, Germany');

// You can chain methods like this because you returned ```$this``` in your ```addTakenCourse()``` method, which is a reference to the same object you are working with.
$IndustriousStudent->addTakenCourse('Advanced Python')->addTakenCourse('Advanced PHP')->addTakenCourse('Particle Physics');
print_r($IndustriousStudent);
```

Notice how the object is now of type ```Student``` not ```Person```. Also notice how the ```id```, ```name``` and ```address```
properties are inherited from the parent class ```Person```

```
Student Object
(
    [coursesTaken:protected] => Array
        (
            [0] => Advanced Python
            [1] => Advanced PHP
            [2] => Particle Physics
        )

    [id:protected] => 123
    [name:protected] => Albert Einstein
    [address:protected] => Munich, Germany
)
```

Lets create an ```Instructor``` and add some taught courses
```php
<?php

$ACAInstructor = new Instructor(456, 'Samir Patel', 'Austin TX');
$ACAInstructor->addTaughtCourse('Intermediate PHP');
$ACAInstructor->addTaughtCourse('Advanced PHP');
$ACAInstructor->addTaughtCourse('Golfing like a boss');
print_r($ACAInstructor);
```

Notice how the object is of type ```Instructor``` and has the ```$coursesTaught``` property instead of ```$coursesTaken```
```
Instructor Object
(
    [coursesTaught:protected] => Array
        (
            [0] => Intermediate PHP
            [1] => Advanced PHP
            [2] => Golfing like a boss
        )

    [id:protected] => 456
    [name:protected] => Samir Patel
    [address:protected] => Austin TX
)
```

Classes explained
-----------------

#### Constructors, arguments and overloading
A constructor looks like this ```___construct()```. A constructor is a way for you to define the arguments the class
will take when you instantiate it. When we say ```$Obj = new MyCoolClass();``` we are *instantiating* the class into an object.

Lets create a simple class called ```Weather```.
Notice that this class has two constructor arguments, ```$temperature``` and ```$location```. The ```$location``` argument is overridden.
In other words, you don't need to specify the location when you instantiate the class, as its optional.

```php
<?php

class Weather
{
    /**
     * @param float $temperature Temperature in fahrenheit
     * @param string $location City name
     */
    public function __construct($temperature, $location = 'Austin')
    {
        if ($temperature > 80) {
            echo "It is super hot in $location";
        } else {
            echo "Its really cold in $location";
        }
    }
}
```
Let's instantiate this class in a few different ways, and examine the output.
```php
<?php

$East = new Weather(88.50, 'Bombay'); // It is super hot in Bombay

$North = new Weather(60.34, 'Alaska'); // Its really cold in Alaska
```

#### Public, private and protected methods and properties
A method is simply a function inside of a class. A property is a variable inside a class.
PHP has three levels of visibility that apply to methods and properties.

* ```public``` - Anything prefixed with the public keyword can be accessed and mutated from anywhere.
* ```protected``` - This prefix only allows the current class and any child class visibility and mutability.
* ```private``` - Private methods and properties can only be accessed from within the class that they were defined.

The reason why we have the ability to control visibility so when other developers read our code, it becomes clear to them
what we want them to be able to modify and what is off limits. Lets take a look at an example of how visibility is useful.

*
* Class constants
* Static methods
* Static properties
* How to access object properties
* The $this keyword
* The self keyword

### Abstract Classes & Interfaces
* What is an abstract class?
* What is an interface?
* Whats the difference?
* What can we use this for?

### Exceptions revisited
* Base Exception class
* Overriding Exception by extending
* Why would we want to override the base Exception class?
* How to throw your own Exceptions and why it matters